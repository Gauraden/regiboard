--- ./build/u-boot-2009.08.01-regigraf/Makefile.orig	2013-08-13 13:16:40.683148600 +0400
+++ ./build/u-boot-2009.08.01-regigraf/Makefile	2013-08-13 13:14:50.000000000 +0400
@@ -3296,6 +3296,9 @@
 mx53_loco_config	:unconfig
 	$(MKCONFIG) $(@:_config=) arm arm_cortexa8 mx53_loco freescale mx53
 
+mx53_regigraf_config	:unconfig
+	$(MKCONFIG) $(@:_config=) arm arm_cortexa8 mx53_regigraf freescale mx53
+
 mx53_ard_ddr3_mfg_config	\
 mx53_ard_ddr3_config		\
 mx53_ard_mfg_config		\
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx51_regigraf/lowlevel_init.S.orig	2012-09-07 13:00:17.000000000 +0400
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx51_regigraf/lowlevel_init.S	2013-06-04 14:19:47.429730997 +0400
@@ -272,10 +272,14 @@
 
 	/* setup the rest */
 	/* Use lp_apm (24MHz) source for perclk */
+	/*ldr r1, =0x000020C2 */         /* original */
+	/* str r1, [r0, #CLKCTL_CBCMR]*/ /* original */
 	ldr r1, =0x000020C2
+	orr r1,r1,#CONFIG_SYS_DDR_CLKSEL
 	str r1, [r0, #CLKCTL_CBCMR]
 	/* ddr clock from PLL 1, all perclk dividers are 1 since using 24MHz */
-	ldr r1, =0x59E35100
+	/* ldr r1, =0x59E35100 */ /* original */
+	ldr r1, =CONFIG_SYS_CLKTL_CBCDR
 	str r1, [r0, #CLKCTL_CBCDR]
 
 	/* Restore the default values in the Gate registers */
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/config.mk ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/config.mk
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/config.mk	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/config.mk	2012-09-07 13:00:17.000000000 +0400
@@ -0,0 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
+TEXT_BASE = 0x77800000
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/.depend ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/.depend
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/.depend	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/.depend	2013-08-13 13:36:13.908399161 +0400
@@ -0,0 +1,66 @@
+lowlevel_init.o: lowlevel_init.S \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/config.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/configs/mx53_regigraf.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/arch/mx53.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/config_cmd_default.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/config.h
+flash_header.o: flash_header.S \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/config.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/configs/mx53_regigraf.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/arch/mx53.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/config_cmd_default.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/config.h
+mx53_regigraf.o: mx53_regigraf.c \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/common.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/config.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/configs/mx53_regigraf.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/arch/mx53.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/config_cmd_default.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/config.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/bitops.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/types.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/bitops.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/proc/system.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/config.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/types.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/posix_types.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/stddef.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/posix_types.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/string.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/string.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/ptrace.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/proc/ptrace.h \
+ /home/denis/Projects/regiboard/output/toolchain/toolchain.cortex_a8/lib/gcc/arm-cortex_a8-linux-gnueabi/4.5.4/include/stdarg.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/part.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/ide.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/flash.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/image.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/compiler.h \
+ /home/denis/Projects/regiboard/output/toolchain/toolchain.cortex_a8/lib/gcc/arm-cortex_a8-linux-gnueabi/4.5.4/include/stddef.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/byteorder.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/byteorder/little_endian.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/byteorder/swab.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/byteorder/generic.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/lmb.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/u-boot.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/command.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/global_data.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/mach-types.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/setup.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/u-boot-arm.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/io.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/memory.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/arch/mx53_pins.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/arch/iomux.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/errno.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm-generic/errno.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/netdev.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/i2c.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/mmc.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/list.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/linux/poison.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/fsl_esdhc.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/mmu.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/system.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/arch/mmu.h \
+ /home/denis/Projects/regiboard/build/u-boot-2009.08.01-regigraf/include/asm/clock.h
Двоичные файлы ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/flash_header.o и ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/flash_header.o различаются
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/flash_header.S ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/flash_header.S
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/flash_header.S	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/flash_header.S	2012-09-07 13:00:17.000000000 +0400
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/mx53.h>
+
+#define REG_LD_AND_STR_INIT(base)	\
+	ldr r0, =base;
+
+#define REG_LD_AND_STR_OP(i, offset, val)	\
+	ldr r1, =val;	\
+	ldr r2, =offset;	\
+	str r1, [r0, r2];
+
+#define REG_LD_AND_STR_END(base)
+
+
+#ifdef	CONFIG_FLASH_HEADER
+#ifndef CONFIG_FLASH_HEADER_OFFSET
+# error "Must define the offset of flash header"
+#endif
+
+.section ".text.flasheader", "x"
+	b	_start
+	.org	CONFIG_FLASH_HEADER_OFFSET
+
+ivt_header:		.long 0x402000D1/* Tag=0xD1, Len=0x0020, Ver=0x40 */
+app_code_jump_v:	.long (0xF8006000 + (plugin_start - TEXT_BASE))
+reserv1:		.long 0x0
+dcd_ptr:		.long 0x0
+boot_data_ptr:		.long (0xF8006000 + (boot_data - TEXT_BASE))
+self_ptr:		.long (0xF8006000 + (ivt_header - TEXT_BASE))
+app_code_csf:		.long 0x0
+reserv2:		.long 0x0
+boot_data:		.long 0xF8006000
+image_len:		.long (3 * 1024)
+plugin:			.long 0x1
+
+/* Second IVT to give entry point into the bootloader copied to DDR */
+ivt2_header:		.long 0x402000D1/*Tag=0xD1, Len=0x0020, Ver=0x40 */
+app2_code_jump_v:	.long _start   /* Entry point for the bootloader */
+reserv3:		.long 0x0
+dcd2_ptr:		.long 0x0
+boot_data2_ptr:		.long boot_data2
+self_ptr2:		.long ivt2_header
+app_code_csf2:		.long 0x0
+reserv4:		.long 0x0
+boot_data2:		.long TEXT_BASE
+image_len2:		.long  _end_of_copy - TEXT_BASE + CONFIG_FLASH_HEADER_OFFSET
+plugin2:		.long 0x0
+
+/* Here starts the plugin code */
+plugin_start:
+	/* Save the return address and the function arguments */
+	push {r0-r6, lr}
+	/* We should distinguish USB recovery mode(SDP mode) and internal boot mode.
+	If ROM runs in SDP mode, then it needn't load boot code from storage media.
+	If ROM runs in SDP mode, then r0 must be 0x00
+	If ROM runs in internal boot mode, then r0 should be larger than IRAM base address. */
+	mov r7, r0
+
+	/* IOMUX */
+	REG_LD_AND_STR_INIT(IOMUXC_BASE_ADDR)
+	REG_LD_AND_STR_OP(1, 0x554, 0x00300000)
+	REG_LD_AND_STR_OP(2, 0x558, 0x00300040)
+	REG_LD_AND_STR_OP(3, 0x560, 0x00300000)
+	REG_LD_AND_STR_OP(4, 0x564, 0x00300040)
+	REG_LD_AND_STR_OP(5, 0x568, 0x00300040)
+	REG_LD_AND_STR_OP(6, 0x570, 0x00300000)
+	REG_LD_AND_STR_OP(7, 0x574, 0x00300000)
+	REG_LD_AND_STR_OP(8, 0x578, 0x00300000)
+	REG_LD_AND_STR_OP(9, 0x57c, 0x00300040)
+	REG_LD_AND_STR_OP(10, 0x580, 0x00300040)
+	REG_LD_AND_STR_OP(11, 0x584, 0x00300000)
+	REG_LD_AND_STR_OP(12, 0x588, 0x00300000)
+	REG_LD_AND_STR_OP(13, 0x590, 0x00300040)
+	REG_LD_AND_STR_OP(14, 0x594, 0x00300000)
+	REG_LD_AND_STR_OP(15, 0x6f0, 0x00300000)
+	REG_LD_AND_STR_OP(16, 0x6f4, 0x00000000)
+	REG_LD_AND_STR_OP(17, 0x6fc, 0x00000000)
+	REG_LD_AND_STR_OP(18, 0x714, 0x00000000)
+	REG_LD_AND_STR_OP(19, 0x718, 0x00300000)
+	REG_LD_AND_STR_OP(20, 0x71c, 0x00300000)
+	REG_LD_AND_STR_OP(21, 0x720, 0x00300000)
+	REG_LD_AND_STR_OP(22, 0x724, 0x04000000)
+	REG_LD_AND_STR_OP(23, 0x728, 0x00300000)
+	REG_LD_AND_STR_OP(24, 0x72c, 0x00300000)
+	REG_LD_AND_STR_END(IOMUXC_BASE_ADDR)
+
+	/* ESDCTL */
+	REG_LD_AND_STR_INIT(ESDCTL_BASE_ADDR)
+	REG_LD_AND_STR_OP(25, 0x088, 0x35343535)
+	REG_LD_AND_STR_OP(26, 0x090, 0x4d444c44)
+	REG_LD_AND_STR_OP(27, 0x07c, 0x01370138)
+	REG_LD_AND_STR_OP(28, 0x080, 0x013b013c)
+	REG_LD_AND_STR_OP(29, 0x018, 0x00001740)
+	REG_LD_AND_STR_OP(30, 0x000, 0xc3190000)
+/*	REG_LD_AND_STR_OP(31, 0x00c, 0x9f5152e3) */
+	REG_LD_AND_STR_OP(31, 0x00c, 0x404452e3)
+	
+/*	REG_LD_AND_STR_OP(32, 0x010, 0xb68e8a63) */
+	REG_LD_AND_STR_OP(32, 0x010, 0xb68e8a63)
+
+	REG_LD_AND_STR_OP(33, 0x014, 0x01ff00db)
+	REG_LD_AND_STR_OP(34, 0x02c, 0x000026d2)
+	REG_LD_AND_STR_OP(35, 0x030, 0x009f0e21)
+	REG_LD_AND_STR_OP(36, 0x008, 0x12273030)
+	REG_LD_AND_STR_OP(37, 0x004, 0x0002002d)
+	REG_LD_AND_STR_OP(38, 0x01c, 0x00008032)
+	REG_LD_AND_STR_OP(39, 0x01c, 0x00008033)
+	REG_LD_AND_STR_OP(40, 0x01c, 0x00028031)
+	REG_LD_AND_STR_OP(41, 0x01c, 0x052080b0)
+	REG_LD_AND_STR_OP(42, 0x01c, 0x04008040)
+	REG_LD_AND_STR_OP(43, 0x01c, 0x0000803a)
+	REG_LD_AND_STR_OP(44, 0x01c, 0x0000803b)
+	REG_LD_AND_STR_OP(45, 0x01c, 0x00028039)
+	REG_LD_AND_STR_OP(46, 0x01c, 0x05208138)
+	REG_LD_AND_STR_OP(47, 0x01c, 0x04008048)
+	REG_LD_AND_STR_OP(48, 0x020, 0x00005800)
+	REG_LD_AND_STR_OP(49, 0x040, 0x04b80003)
+	REG_LD_AND_STR_OP(50, 0x058, 0x00022227)
+	REG_LD_AND_STR_OP(51, 0x01C, 0x00000000)
+	REG_LD_AND_STR_END(ESDCTL_BASE_ADDR)
+
+/*
+ *  The following is to fill in those arguments for this ROM function
+ * pu_irom_hwcnfg_setup(void **start, size_t *bytes, const void *boot_data)
+ *
+ *  This function is used to copy data from the storage media into DDR.
+ *
+ *  start - Initial (possibly partial) image load address on entry. Final image
+ *            load address on exit.
+ *  bytes - Initial (possibly partial) image size on entry. Final image size on
+ *             exit.
+ *  boot_data - Initial @ref ivt Boot Data load address.
+ */
+	adr r0, DDR_DEST_ADDR
+	adr r1, COPY_SIZE
+	adr r2, BOOT_DATA
+before_calling_rom___pu_irom_hwcnfg_setup:
+
+	/* We should distinguish USB recovery mode(SDP mode) and internal boot mode.
+	If ROM runs in SDP mode, then it needn't load boot code from storage media.
+	If ROM runs in SDP mode, then r0 must be 0x00
+	If ROM runs in internal boot mode, then r0 should be larger than IRAM base address. */
+	cmp r7, #0xF8000000
+	bls return_sdp
+	/* Different ROM address for TO 1.0 & TO 2.0 */
+	ldr r3, =ROM_SI_REV
+	ldr r4, [r3]
+
+	cmp r4, #0x21
+	/* TO2.1 */
+	moveq r6, #0x1800
+	addeq r6, r6, #0x4d
+	beq 2f
+
+	cmp r4, #0x20
+	/* TO2 */
+	moveq r6, #0x1800
+	addeq r6, r6, #0x4d
+	beq 2f
+
+	/* TO1 */
+	mov r6, #0x400000
+	add r6, r6, #0x5000
+	add r6, r6, #0xc7
+
+2:
+	blx r6 /* This address might change in future ROM versions */
+after_calling_rom___pu_irom_hwcnfg_setup:
+
+return_sdp:
+	cmp r7, #0xF8000000
+	bhi quit_plugin
+
+	/* Workaround run plug-ins in SDP mode without USB re-enumeration.
+	how it works:
+	ROM running in usb download mode.
+	Host manufacturing application sends SDP command to download plug-in image.
+	Host manufacturing application sends SDP command to jump to plug-in image and run it.
+	Plug-in starts execution and after its regular tasks plug-in will then call into ROM
+	call into pl_parse_and_handle() */
+	ldr r3, =ROM_SI_REV
+	ldr r5, [r3]
+	cmp r5, #0x20       /* check silicon revision to determine the function entry address */
+
+	ldrlt r4, =0x00000edd   /* function entry in TO1 ROM */
+	ldrge r4, =0x0040487d   /* function entry in TO2 ROM */
+	blx r4
+
+/* To return to ROM from plugin, we need to fill in these argument.
+ * Here is what need to do:
+ * Need to construct the paramters for this function before return to ROM:
+ * plugin_download(void **start, size_t *bytes, UINT32 *ivt_offset)
+ */
+quit_plugin:
+	pop {r0-r6, lr}
+	ldr r4, DDR_DEST_ADDR
+	str r4, [r0]
+	ldr r4, COPY_SIZE
+	str r4, [r1]
+	mov r4, #0x400  /* Point to the second IVT table at offset 0x42C */
+	add r4, r4, #0x2C
+	str r4, [r2]
+	mov r0, #1
+
+	bx lr  /* return back to ROM code */
+
+DDR_DEST_ADDR:    .word   TEXT_BASE
+COPY_SIZE:        .word   _end - TEXT_BASE
+BOOT_DATA:        .word   TEXT_BASE
+                  .word   _end - TEXT_BASE
+                  .word   0
+
+#endif
Двоичные файлы ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/libmx53_regigraf.a и ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/libmx53_regigraf.a различаются
Двоичные файлы ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/lowlevel_init.o и ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/lowlevel_init.o различаются
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/lowlevel_init.S ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/lowlevel_init.S
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/lowlevel_init.S	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/lowlevel_init.S	2012-09-07 13:00:17.000000000 +0400
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/mx53.h>
+
+/*
+ * L2CC Cache setup/invalidation/disable
+ */
+.macro init_l2cc
+	/* explicitly disable L2 cache */
+        mrc 15, 0, r0, c1, c0, 1
+        bic r0, r0, #0x2
+        mcr 15, 0, r0, c1, c0, 1
+
+        /* reconfigure L2 cache aux control reg */
+        mov r0, #0xC0                   /* tag RAM */
+        add r0, r0, #0x4                /* data RAM */
+        orr r0, r0, #(1 << 24)          /* disable write allocate delay */
+        orr r0, r0, #(1 << 23)          /* disable write allocate combine */
+        orr r0, r0, #(1 << 22)          /* disable write allocate */
+
+	mcr 15, 1, r0, c9, c0, 2
+.endm /* init_l2cc */
+
+/* AIPS setup - Only setup MPROTx registers.
+ * The PACR default values are good.*/
+.macro init_aips
+	/*
+	 * Set all MPROTx to be non-bufferable, trusted for R/W,
+	 * not forced to user-mode.
+	 */
+	ldr r0, =AIPS1_BASE_ADDR
+	ldr r1, =0x77777777
+	str r1, [r0, #0x0]
+	str r1, [r0, #0x4]
+	ldr r0, =AIPS2_BASE_ADDR
+	str r1, [r0, #0x0]
+	str r1, [r0, #0x4]
+.endm /* init_aips */
+
+.macro setup_pll pll, freq
+	/*
+	 * If freq < 300MHz, we need to set dpdck0_2_en to 0
+	 */
+	ldr r0, =\freq
+	ldr r1, =0x300
+	cmp r0, r1
+	ldrcs r1, =0x00001232
+	ldrcc r1, =0x00000232
+	ldr r0, =\pll
+	str r1, [r0, #PLL_DP_CTL]
+	mov r1, #0x2
+	str r1, [r0, #PLL_DP_CONFIG]
+
+	ldr r1, W_DP_OP_\freq
+	str r1, [r0, #PLL_DP_OP]
+	str r1, [r0, #PLL_DP_HFS_OP]
+
+	ldr r1,	W_DP_MFD_\freq
+	str r1, [r0, #PLL_DP_MFD]
+	str r1, [r0, #PLL_DP_HFS_MFD]
+
+	ldr r1,  W_DP_MFN_\freq
+	str r1, [r0, #PLL_DP_MFN]
+	str r1, [r0, #PLL_DP_HFS_MFN]
+
+	ldr r1, =0x00001232
+	str r1, [r0, #PLL_DP_CTL]
+1:	ldr r1, [r0, #PLL_DP_CTL]
+	ands r1, r1, #0x1
+	beq 1b
+.endm
+
+.macro init_clock
+	ldr r0, =ROM_SI_REV
+	ldr r1, [r0]
+	cmp r1, #0x20
+
+	/* For TO2 only, set LDO to 1.3V */
+	ldr r0, =0x53fa8000
+	ldr r1, =0x00194005
+	streq r1, [r0, #0x04]
+
+	ldr r0, CCM_BASE_ADDR_W
+
+	/* Gate of clocks to the peripherals first */
+	ldr r1, =0x3FFFFFFF
+	str r1, [r0, #CLKCTL_CCGR0]
+	ldr r1, =0x0
+	str r1, [r0, #CLKCTL_CCGR1]
+	str r1, [r0, #CLKCTL_CCGR2]
+	str r1, [r0, #CLKCTL_CCGR3]
+	str r1, [r0, #CLKCTL_CCGR7]
+	ldr r1, =0x00030000
+	str r1, [r0, #CLKCTL_CCGR4]
+	ldr r1, =0x00FFF030
+	str r1, [r0, #CLKCTL_CCGR5]
+	ldr r1, =0x0F00030F
+	str r1, [r0, #CLKCTL_CCGR6]
+
+	/* Switch ARM to step clock */
+	mov r1, #0x4
+	str r1, [r0, #CLKCTL_CCSR]
+
+	setup_pll PLL1_BASE_ADDR, 800
+
+        setup_pll PLL3_BASE_ADDR, 400
+
+        /* Switch peripheral to PLL3 */
+        ldr r0, CCM_BASE_ADDR_W
+        ldr r1, CCM_VAL_0x00015154
+        str r1, [r0, #CLKCTL_CBCMR]
+        ldr r1, CCM_VAL_0x02888945
+        orr r1, r1, #(1 << 16)
+        str r1, [r0, #CLKCTL_CBCDR]
+        /* make sure change is effective */
+1:      ldr r1, [r0, #CLKCTL_CDHIPR]
+        cmp r1, #0x0
+        bne 1b
+
+        setup_pll PLL2_BASE_ADDR, CONFIG_SYS_PLL2_FREQ
+
+	/* Switch peripheral to PLL2 */
+	ldr r0, CCM_BASE_ADDR_W
+	ldr r1, CCM_VAL_0x00808145
+	orr r1, r1, #(CONFIG_SYS_AHB_PODF << 10)
+	orr r1, r1, #(CONFIG_SYS_AXIA_PODF << 16)
+	orr r1, r1, #(CONFIG_SYS_AXIB_PODF << 19)
+	str r1, [r0, #CLKCTL_CBCDR]
+
+	ldr r1, CCM_VAL_0x00016154
+	str r1, [r0, #CLKCTL_CBCMR]
+
+	/*change uart clk parent to pll2*/
+	ldr r1, [r0, #CLKCTL_CSCMR1]
+	and r1, r1, #0xfcffffff
+	orr r1, r1, #0x01000000
+	str r1, [r0, #CLKCTL_CSCMR1]
+
+	/* make sure change is effective */
+1:      ldr r1, [r0, #CLKCTL_CDHIPR]
+	cmp r1, #0x0
+	bne 1b
+
+        setup_pll PLL3_BASE_ADDR, 216
+
+	setup_pll PLL4_BASE_ADDR, 455
+
+	/* Set the platform clock dividers */
+	ldr r0, PLATFORM_BASE_ADDR_W
+	ldr r1, PLATFORM_CLOCK_DIV_W
+	str r1, [r0, #PLATFORM_ICGC]
+
+	ldr r0, CCM_BASE_ADDR_W
+	mov r1, #0
+	str r1, [r0, #CLKCTL_CACRR]
+
+	/* Switch ARM back to PLL 1. */
+	mov r1, #0x0
+	str r1, [r0, #CLKCTL_CCSR]
+
+	/* make uart div=6*/
+	ldr r1, [r0, #CLKCTL_CSCDR1]
+	and r1, r1, #0xffffffc0
+	orr r1, r1, #0x0a
+	str r1, [r0, #CLKCTL_CSCDR1]
+
+	/* Restore the default values in the Gate registers */
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #CLKCTL_CCGR0]
+	str r1, [r0, #CLKCTL_CCGR1]
+	str r1, [r0, #CLKCTL_CCGR2]
+	str r1, [r0, #CLKCTL_CCGR3]
+	str r1, [r0, #CLKCTL_CCGR4]
+	str r1, [r0, #CLKCTL_CCGR5]
+	str r1, [r0, #CLKCTL_CCGR6]
+	str r1, [r0, #CLKCTL_CCGR7]
+
+        mov r1, #0x00000
+        str r1, [r0, #CLKCTL_CCDR]
+
+        /* for cko - for ARM div by 8 */
+        mov r1, #0x000A0000
+        add r1, r1, #0x00000F0
+        str r1, [r0, #CLKCTL_CCOSR]
+.endm
+
+.section ".text.init", "x"
+
+.globl lowlevel_init
+lowlevel_init:
+
+#ifdef ENABLE_IMPRECISE_ABORT
+        mrs r1, spsr            /* save old spsr */
+        mrs r0, cpsr            /* read out the cpsr */
+	bic r0, r0, #0x100      /* clear the A bit */
+	msr spsr, r0            /* update spsr */
+	add lr, pc, #0x8        /* update lr */
+        movs pc, lr             /* update cpsr */
+        nop
+        nop
+        nop
+	nop
+	msr spsr, r1            /* restore old spsr */
+#endif
+
+	/* ARM errata ID #468414 */
+	mrc 15, 0, r1, c1, c0, 1
+	orr r1, r1, #(1 << 5)    /* enable L1NEON bit */
+	mcr 15, 0, r1, c1, c0, 1
+
+	init_l2cc
+
+	init_aips
+
+	init_clock
+
+	mov pc, lr
+
+/* Board level setting value */
+CCM_BASE_ADDR_W:        .word CCM_BASE_ADDR
+CCM_VAL_0x00016154:     .word 0x00016154
+CCM_VAL_0x00808145:     .word 0x00808145
+CCM_VAL_0x00015154:     .word 0x00015154
+CCM_VAL_0x02888945:     .word 0x02888945
+W_DP_OP_1000:           .word DP_OP_1000
+W_DP_MFD_1000:          .word DP_MFD_1000
+W_DP_MFN_1000:          .word DP_MFN_1000
+W_DP_OP_800:           	.word DP_OP_800
+W_DP_MFD_800:           .word DP_MFD_800
+W_DP_MFN_800:           .word DP_MFN_800
+W_DP_OP_600:            .word DP_OP_600
+W_DP_MFD_600:           .word DP_MFD_600
+W_DP_MFN_600:           .word DP_MFN_600
+W_DP_OP_400:            .word DP_OP_400
+W_DP_MFD_400:           .word DP_MFD_400
+W_DP_MFN_400:           .word DP_MFN_400
+W_DP_OP_216:            .word DP_OP_216
+W_DP_MFD_216:           .word DP_MFD_216
+W_DP_MFN_216:           .word DP_MFN_216
+W_DP_OP_455:            .word DP_OP_455
+W_DP_MFD_455:           .word DP_MFD_455
+W_DP_MFN_455:           .word DP_MFN_455
+PLATFORM_BASE_ADDR_W:   .word ARM_BASE_ADDR
+PLATFORM_CLOCK_DIV_W:   .word 0x00000124
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/Makefile ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/Makefile
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/Makefile	2013-08-13 13:11:27.067091289 +0400
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2010 Freescale Semiconductor, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= mx53_regigraf.o
+SOBJS	:= lowlevel_init.o flash_header.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/mx53_regigraf.c ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/mx53_regigraf.c
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/mx53_regigraf.c	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/mx53_regigraf.c	2012-09-07 13:00:17.000000000 +0400
@@ -0,0 +1,959 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mx53.h>
+#include <asm/arch/mx53_pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/errno.h>
+#include <netdev.h>
+
+#if CONFIG_I2C_MXC
+#include <i2c.h>
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#endif
+
+#ifdef CONFIG_ARCH_MMU
+#include <asm/mmu.h>
+#include <asm/arch/mmu.h>
+#endif
+
+#ifdef CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
+#include <asm/imx_iim.h>
+#endif
+
+#ifdef CONFIG_CMD_CLOCK
+#include <asm/clock.h>
+#endif
+
+#ifdef CONFIG_ANDROID_RECOVERY
+#include "../common/recovery.h"
+#include <part.h>
+#include <ext2fs.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <ubi_uboot.h>
+#include <jffs2/load_kernel.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static u32 system_rev;
+static enum boot_device boot_dev;
+
+u32 get_board_rev_from_fuse(void)
+{
+	u32 board_rev = readl(IIM_BASE_ADDR + 0x878);
+
+	return board_rev;
+}
+
+static inline void setup_boot_device(void)
+{
+	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	uint bt_mem_ctl = (soc_sbmr & 0x000000FF) >> 4 ;
+	uint bt_mem_type = (soc_sbmr & 0x00000008) >> 3;
+
+	switch (bt_mem_ctl) {
+	case 0x0:
+		if (bt_mem_type)
+			boot_dev = ONE_NAND_BOOT;
+		else
+			boot_dev = WEIM_NOR_BOOT;
+		break;
+	case 0x2:
+		if (bt_mem_type)
+			boot_dev = SATA_BOOT;
+		else
+			boot_dev = PATA_BOOT;
+		break;
+	case 0x3:
+		if (bt_mem_type)
+			boot_dev = SPI_NOR_BOOT;
+		else
+			boot_dev = I2C_BOOT;
+		break;
+	case 0x4:
+	case 0x5:
+		boot_dev = SD_BOOT;
+		break;
+	case 0x6:
+	case 0x7:
+		boot_dev = MMC_BOOT;
+		break;
+	case 0x8 ... 0xf:
+		boot_dev = NAND_BOOT;
+		break;
+	default:
+		boot_dev = UNKNOWN_BOOT;
+		break;
+	}
+}
+
+enum boot_device get_boot_device(void)
+{
+	return boot_dev;
+}
+
+u32 get_board_rev(void)
+{
+	return system_rev;
+}
+
+static inline void setup_soc_rev(void)
+{
+	int reg;
+
+	/* Si rev is obtained from ROM */
+	reg = __REG(ROM_SI_REV);
+
+	switch (reg) {
+	case 0x10:
+		system_rev = 0x53000 | CHIP_REV_1_0;
+		break;
+	case 0x20:
+		system_rev = 0x53000 | CHIP_REV_2_0;
+		break;
+	case 0x21:
+		system_rev = 0x53000 | CHIP_REV_2_1;
+		break;
+	default:
+		system_rev = 0x53000 | CHIP_REV_UNKNOWN;
+	}
+}
+
+static inline void setup_board_rev(int rev)
+{
+	system_rev |= (rev & 0xF) << 8;
+}
+
+inline int is_soc_rev(int rev)
+{
+	return (system_rev & 0xFF) - rev;
+}
+
+#ifdef CONFIG_ARCH_MMU
+void board_mmu_init(void)
+{
+	unsigned long ttb_base = PHYS_SDRAM_1 + 0x4000;
+	unsigned long i;
+
+	/*
+	* Set the TTB register
+	*/
+	asm volatile ("mcr  p15,0,%0,c2,c0,0" : : "r"(ttb_base) /*:*/);
+
+	/*
+	* Set the Domain Access Control Register
+	*/
+	i = ARM_ACCESS_DACR_DEFAULT;
+	asm volatile ("mcr  p15,0,%0,c3,c0,0" : : "r"(i) /*:*/);
+
+	/*
+	* First clear all TT entries - ie Set them to Faulting
+	*/
+	memset((void *)ttb_base, 0, ARM_FIRST_LEVEL_PAGE_TABLE_SIZE);
+	/* Actual   Virtual  Size   Attributes          Function */
+	/* Base     Base     MB     cached? buffered?  access permissions */
+	/* xxx00000 xxx00000 */
+	X_ARM_MMU_SECTION(0x000, 0x000, 0x010,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* ROM, 16M */
+	X_ARM_MMU_SECTION(0x010, 0x010, 0x060,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* Reserved, 96M */
+	X_ARM_MMU_SECTION(0x070, 0x070, 0x010,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* IRAM, 16M */
+	X_ARM_MMU_SECTION(0x080, 0x080, 0x080,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* Reserved region + TZIC. 1M */
+	X_ARM_MMU_SECTION(0x100, 0x100, 0x040,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* SATA */
+	X_ARM_MMU_SECTION(0x140, 0x140, 0x040,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* Reserved, 64M */
+	X_ARM_MMU_SECTION(0x180, 0x180, 0x080,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* IPUv3M */
+	X_ARM_MMU_SECTION(0x200, 0x200, 0x200,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* GPU */
+	X_ARM_MMU_SECTION(0x400, 0x400, 0x300,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* periperals */
+	X_ARM_MMU_SECTION(0x700, 0x700, 0x200,
+			ARM_CACHEABLE, ARM_BUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CSD0 512M */
+	X_ARM_MMU_SECTION(0x700, 0x900, 0x200,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CSD0 512M */
+	X_ARM_MMU_SECTION(0xB00, 0xB00, 0x200,
+			ARM_CACHEABLE, ARM_BUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CSD0 512M */
+	X_ARM_MMU_SECTION(0xB00, 0xD00, 0x200,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CSD0 512M */
+	X_ARM_MMU_SECTION(0xF00, 0xF00, 0x07F,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CS1 EIM control*/
+	X_ARM_MMU_SECTION(0xF7F, 0xF7F, 0x001,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* NAND Flash buffer */
+	X_ARM_MMU_SECTION(0xF80, 0xF80, 0x080,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* iRam + GPU3D + Reserved */
+
+	/* Workaround for arm errata #709718 */
+	/* Setup PRRR so device is always mapped to non-shared */
+	asm volatile ("mrc p15, 0, %0, c10, c2, 0" : "=r"(i) : /*:*/);
+	i &= (~(3 << 0x10));
+	asm volatile ("mcr p15, 0, %0, c10, c2, 0" : : "r"(i) /*:*/);
+
+	/* Enable MMU */
+	MMU_ON();
+}
+#endif
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
+	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
+	return 0;
+}
+
+static void setup_uart(void)
+{
+	/* UART1 RXD */
+	mxc_request_iomux(MX53_PIN_CSI0_D11, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX53_PIN_CSI0_D11, 0x1E4);
+	mxc_iomux_set_input(MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT, 0x1);
+
+	/* UART1 TXD */
+	mxc_request_iomux(MX53_PIN_CSI0_D10, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX53_PIN_CSI0_D10, 0x1E4);
+}
+
+#ifdef CONFIG_I2C_MXC
+static void setup_i2c(unsigned int module_base)
+{
+	switch (module_base) {
+	case I2C1_BASE_ADDR:
+		/* i2c1 SDA */
+		mxc_request_iomux(MX53_PIN_CSI0_D8,
+				IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_CSI0_D8, PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+		/* i2c1 SCL */
+		mxc_request_iomux(MX53_PIN_CSI0_D9,
+				IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_CSI0_D9, PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+		break;
+	case I2C2_BASE_ADDR:
+		/* i2c2 SDA */
+		mxc_request_iomux(MX53_PIN_KEY_ROW3,
+				IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_KEY_ROW3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+
+		/* i2c2 SCL */
+		mxc_request_iomux(MX53_PIN_KEY_COL3,
+				IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_KEY_COL3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+
+		break;
+	case I2C3_BASE_ADDR:
+		break;
+	default:
+		printf("Invalid I2C base: 0x%x\n", module_base);
+		break;
+	}
+}
+
+void setup_pmic_voltages(void)
+{
+}
+
+/* DA9053 I2C SDA stuck low issue: the I2C block in DA9053 may not correctly
+ * receive a Power On Reset and device is in unknown state during start-up.
+ * The only way to get the chip into known state before any communication
+ * with the Chip via I2C is to dummy clock the I2C and bring it in a state
+ * where I2C can communicate. Dialog suggested to provide 9 clock on SCL.
+ * Dialog don't know the exact reason for the fault and assume it is because
+ * some random noise or spurious behaviour.
+ * This has to been done in host platform specific I2C driver during
+ * start-up when the I2C is being configured at platform level to supply with
+ * dummy 9 clock on SCL. Dialog I2C driver has no control to provide dummy 9
+ * clock on SCL.
+ */
+#define I2C1_SDA_GPIO5_26_BIT_MASK  (1 << 26)
+#define I2C1_SCL_GPIO5_27_BIT_MASK  (1 << 27)
+void i2c_failed_handle(void)
+{
+	unsigned int reg, i, retry = 10;
+
+	do {
+		/* set I2C1_SDA as GPIO input */
+		mxc_request_iomux(MX53_PIN_CSI0_D8, IOMUX_CONFIG_ALT1);
+		reg = readl(GPIO5_BASE_ADDR + 0x4);
+		reg &= ~I2C1_SDA_GPIO5_26_BIT_MASK;
+		writel(reg, GPIO5_BASE_ADDR + 0x4);
+
+		/* set I2C1_SCL as GPIO output */
+		mxc_request_iomux(MX53_PIN_CSI0_D9, IOMUX_CONFIG_ALT1);
+		reg = readl(GPIO5_BASE_ADDR + 0x0);
+		reg |= I2C1_SCL_GPIO5_27_BIT_MASK;
+		writel(reg, GPIO5_BASE_ADDR + 0x0);
+
+		reg = readl(GPIO5_BASE_ADDR + 0x4);
+		reg |= I2C1_SCL_GPIO5_27_BIT_MASK;
+		writel(reg, GPIO5_BASE_ADDR + 0x4);
+		udelay(10000);
+
+		for (i = 0; i < 10; i++) {
+			reg = readl(GPIO5_BASE_ADDR + 0x0);
+			reg |= I2C1_SCL_GPIO5_27_BIT_MASK;
+			writel(reg, GPIO5_BASE_ADDR + 0x0);
+			udelay(5000);
+
+			reg = readl(GPIO5_BASE_ADDR + 0x0);
+			reg &= ~I2C1_SCL_GPIO5_27_BIT_MASK;
+			writel(reg, GPIO5_BASE_ADDR + 0x0);
+			udelay(5000);
+		}
+		reg = readl(GPIO5_BASE_ADDR + 0x0);
+		reg |= I2C1_SCL_GPIO5_27_BIT_MASK;
+		writel(reg, GPIO5_BASE_ADDR + 0x0);
+		udelay(1000);
+
+		reg = readl(GPIO5_BASE_ADDR + 0x8);
+		if (reg & I2C1_SDA_GPIO5_26_BIT_MASK) {
+			printf("***I2C1_SDA = hight***\n");
+			return;
+		} else {
+			printf("***I2C1_SDA = low***\n");
+		}
+	} while (retry--);
+}
+
+int i2c_read_check(uchar chip, uint addr, int alen, uchar *buf, int len)
+{
+	int ret = 0;
+
+	ret = i2c_read(chip, addr, alen, buf, len);
+	if (ret == 0) {
+		return 0;
+	} else {
+	i2c_failed_handle();
+	setup_i2c(CONFIG_SYS_I2C_PORT);
+	ret = i2c_read(chip, addr, alen, buf, len);
+	if (ret != 0) {
+		printf("[I2C-DA9053]read i2c fail\n");
+		return -1;
+	}
+	return 0;
+	}
+}
+
+int i2c_write_check(uchar chip, uint addr, int alen, uchar *buf, int len)
+{
+	int ret = 0;
+
+	ret = i2c_write(chip, addr, alen, buf, len);
+	if (ret == 0) {
+		return 0;
+	} else {
+		i2c_failed_handle();
+		setup_i2c(CONFIG_SYS_I2C_PORT);
+		i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+		ret = i2c_write(chip, addr, alen, buf, len);
+		if (ret != 0) {
+			printf("[I2C-DA9053]write i2c fail\n");
+			return -1;
+		}
+		return 0;
+	}
+}
+#endif
+
+#if defined(CONFIG_DWC_AHSATA)
+static void setup_sata_device(void)
+{
+	u32 *tmp_base =
+		(u32 *)(IIM_BASE_ADDR + 0x180c);
+	u32 reg;
+	mxc_request_iomux(MX53_PIN_EIM_DA3, IOMUX_CONFIG_ALT1);
+
+	/* GPIO_3_3 */
+	reg = readl(GPIO3_BASE_ADDR);
+	reg |= (0x1 << 3);
+	writel(reg, GPIO3_BASE_ADDR);
+
+	reg = readl(GPIO3_BASE_ADDR + 0x4);
+	reg |= (0x1 << 3);
+	writel(reg, GPIO3_BASE_ADDR + 0x4);
+
+	udelay(1000);
+
+	/* Set USB_PHY1 clk, fuse bank4 row3 bit2 */
+	set_usb_phy1_clk();
+	writel((readl(tmp_base) & (~0x7)) | 0x4, tmp_base);
+}
+#endif
+
+#ifdef CONFIG_MXC_FEC
+#ifdef CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
+
+int fec_get_mac_addr(unsigned char *mac)
+{
+	u32 *iim1_mac_base =
+		(u32 *)(IIM_BASE_ADDR + IIM_BANK_AREA_1_OFFSET +
+			CONFIG_IIM_MAC_ADDR_OFFSET);
+	int i;
+
+	for (i = 0; i < 6; ++i, ++iim1_mac_base)
+		mac[i] = (u8)readl(iim1_mac_base);
+
+	return 0;
+}
+#endif
+
+static void setup_fec(void)
+{
+	volatile unsigned int reg;
+
+	/*FEC_MDIO*/
+	mxc_request_iomux(MX53_PIN_FEC_MDIO, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_MDIO, 0x1FC);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_MDI_SELECT_INPUT, 0x1);
+
+	/*FEC_MDC*/
+	mxc_request_iomux(MX53_PIN_FEC_MDC, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_MDC, 0x004);
+
+	/* FEC RXD1 */
+	mxc_request_iomux(MX53_PIN_FEC_RXD1, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_RXD1, 0x180);
+
+	/* FEC RXD0 */
+	mxc_request_iomux(MX53_PIN_FEC_RXD0, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_RXD0, 0x180);
+
+	 /* FEC TXD1 */
+	mxc_request_iomux(MX53_PIN_FEC_TXD1, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_TXD1, 0x004);
+
+	/* FEC TXD0 */
+	mxc_request_iomux(MX53_PIN_FEC_TXD0, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_TXD0, 0x004);
+
+	/* FEC TX_EN */
+	mxc_request_iomux(MX53_PIN_FEC_TX_EN, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_TX_EN, 0x004);
+
+	/* FEC TX_CLK */
+	mxc_request_iomux(MX53_PIN_FEC_REF_CLK, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_REF_CLK, 0x180);
+
+	/* FEC RX_ER */
+	mxc_request_iomux(MX53_PIN_FEC_RX_ER, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_RX_ER, 0x180);
+
+	/* FEC CRS */
+	mxc_request_iomux(MX53_PIN_FEC_CRS_DV, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_CRS_DV, 0x180);
+
+	/* phy reset: gpio7-6 */
+	mxc_request_iomux(MX53_PIN_ATA_DA_0, IOMUX_CONFIG_ALT1);
+
+	reg = readl(GPIO7_BASE_ADDR + 0x0);
+	reg &= ~0x40;
+	writel(reg, GPIO7_BASE_ADDR + 0x0);
+
+	reg = readl(GPIO7_BASE_ADDR + 0x4);
+	reg |= 0x40;
+	writel(reg, GPIO7_BASE_ADDR + 0x4);
+
+	udelay(1000);
+
+	reg = readl(GPIO7_BASE_ADDR + 0x0);
+	reg |= 0x40;
+	writel(reg, GPIO7_BASE_ADDR + 0x0);
+
+}
+#endif
+
+
+#ifdef CONFIG_NET_MULTI
+int board_eth_init(bd_t *bis)
+{
+	int rc = -ENODEV;
+
+	return rc;
+}
+#endif
+
+#ifdef CONFIG_CMD_MMC
+
+struct fsl_esdhc_cfg esdhc_cfg[2] = {
+	{MMC_SDHC1_BASE_ADDR, 1, 1},
+	{MMC_SDHC3_BASE_ADDR, 1, 1},
+};
+
+#ifdef CONFIG_DYNAMIC_MMC_DEVNO
+int get_mmc_env_devno(void)
+{
+	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	return (soc_sbmr & 0x00300000) ? 1 : 0;
+}
+#endif
+
+#ifdef CONFIG_EMMC_DDR_PORT_DETECT
+int detect_mmc_emmc_ddr_port(struct fsl_esdhc_cfg *cfg)
+{
+	return (MMC_SDHC3_BASE_ADDR == cfg->esdhc_base) ? 1 : 0;
+}
+#endif
+
+int esdhc_gpio_init(bd_t *bis)
+{
+	s32 status = 0;
+	u32 index = 0;
+
+	for (index = 0; index < CONFIG_SYS_FSL_ESDHC_NUM;
+		++index) {
+		switch (index) {
+		case 0:
+			mxc_request_iomux(MX53_PIN_SD1_CMD, IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_CLK, IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA0,
+						IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA1,
+						IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA2,
+						IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA3,
+						IOMUX_CONFIG_ALT0);
+
+			mxc_iomux_set_pad(MX53_PIN_SD1_CMD, 0x1E4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_CLK, 0xD4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA0, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA1, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA2, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA3, 0x1D4);
+			break;
+		case 1:
+			mxc_request_iomux(MX53_PIN_ATA_RESET_B,
+						IOMUX_CONFIG_ALT2);
+			mxc_request_iomux(MX53_PIN_ATA_IORDY,
+						IOMUX_CONFIG_ALT2);
+			mxc_request_iomux(MX53_PIN_ATA_DATA8,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA9,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA10,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA11,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA0,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA1,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA2,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA3,
+						IOMUX_CONFIG_ALT4);
+
+			mxc_iomux_set_pad(MX53_PIN_ATA_RESET_B, 0x1E4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_IORDY, 0xD4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA8, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA9, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA10, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA11, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA0, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA1, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA2, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA3, 0x1D4);
+
+			break;
+		default:
+			printf("Warning: you configured more ESDHC controller"
+				"(%d) as supported by the board(2)\n",
+				CONFIG_SYS_FSL_ESDHC_NUM);
+			return status;
+		}
+		status |= fsl_esdhc_initialize(bis, &esdhc_cfg[index]);
+	}
+
+	return status;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	if (!esdhc_gpio_init(bis))
+		return 0;
+	else
+		return -1;
+}
+
+#endif
+
+
+int board_init(void)
+{
+#ifdef CONFIG_MFG
+/* MFG firmware need reset usb to avoid host crash firstly */
+#define USBCMD 0x140
+	int val = readl(OTG_BASE_ADDR + USBCMD);
+	val &= ~0x1; /*RS bit*/
+	writel(val, OTG_BASE_ADDR + USBCMD);
+#endif
+	setup_boot_device();
+	setup_soc_rev();
+
+	gd->bd->bi_arch_number = MACH_TYPE_MX53_LOCO;	/* board id for linux */
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
+
+	setup_uart();
+
+#ifdef CONFIG_MXC_FEC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_I2C_MXC
+	setup_i2c(CONFIG_SYS_I2C_PORT);
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+    /* delay pmic i2c access to board_late_init()
+       due to i2c_probe fail here on loco/ripley board. */
+	/* Increase VDDGP voltage */
+	/* setup_pmic_voltages(); */
+	/* Switch to 1GHZ */
+	/* clk_config(CONFIG_REF_CLK_FREQ, 1000, CPU_CLK); */
+#endif
+
+#if defined(CONFIG_DWC_AHSATA)
+	setup_sata_device();
+#endif
+
+	return 0;
+}
+
+
+#ifdef CONFIG_ANDROID_RECOVERY
+struct reco_envs supported_reco_envs[BOOT_DEV_NUM] = {
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
+	 .args = CONFIG_ANDROID_RECOVERY_BOOTARGS_MMC,
+	 },
+	{
+	 .cmd = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
+	 .args = CONFIG_ANDROID_RECOVERY_BOOTARGS_MMC,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+};
+
+int check_recovery_cmd_file(void)
+{
+	disk_partition_t info;
+	ulong part_length;
+	int filelen;
+	char *env;
+
+	/* For test only */
+	/* When detecting android_recovery_switch,
+	 * enter recovery mode directly */
+	env = getenv("android_recovery_switch");
+	if (!strcmp(env, "1")) {
+		printf("Env recovery detected!\nEnter recovery mode!\n");
+		return 1;
+	}
+
+	printf("Checking for recovery command file...\n");
+	switch (get_boot_device()) {
+	case MMC_BOOT:
+	case SD_BOOT:
+		{
+			block_dev_desc_t *dev_desc = NULL;
+			struct mmc *mmc = find_mmc_device(0);
+
+			dev_desc = get_dev("mmc", 0);
+
+			if (NULL == dev_desc) {
+				puts("** Block device MMC 0 not supported\n");
+				return 0;
+			}
+
+			mmc_init(mmc);
+
+			if (get_partition_info(dev_desc,
+					CONFIG_ANDROID_CACHE_PARTITION_MMC,
+					&info)) {
+				printf("** Bad partition %d **\n",
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+				return 0;
+			}
+
+			part_length = ext2fs_set_blk_dev(dev_desc,
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+			if (part_length == 0) {
+				printf("** Bad partition - mmc 0:%d **\n",
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+				ext2fs_close();
+				return 0;
+			}
+
+			if (!ext2fs_mount(part_length)) {
+				printf("** Bad ext2 partition or "
+					"disk - mmc 0:%d **\n",
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+				ext2fs_close();
+				return 0;
+			}
+
+			filelen = ext2fs_open(CONFIG_ANDROID_RECOVERY_CMD_FILE);
+
+			ext2fs_close();
+		}
+		break;
+	case NAND_BOOT:
+		return 0;
+		break;
+	case SPI_NOR_BOOT:
+		return 0;
+		break;
+	case UNKNOWN_BOOT:
+	default:
+		return 0;
+		break;
+	}
+
+	return (filelen > 0) ? 1 : 0;
+
+}
+#endif
+
+/* restore VUSB 2V5 active after suspend */
+#define BUCKPERI_RESTORE_SW_STEP   (0x55)
+/* restore VUSB 2V5 power supply after suspend */
+#define SUPPLY_RESTORE_VPERISW_EN  (0x20)
+#define DA9052_ID1213_REG                  (35)
+#define DA9052_SUPPLY_REG                  (60)
+
+int board_late_init(void)
+{
+	uchar value;
+	unsigned char buf[4] = { 0 };
+	int retries = 10, ret = -1;
+
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 24, 1, &buf[0], 3)) {
+			printf("%s:i2c_read:error\n", __func__);
+			return -1;
+		}
+		/* increase VDDGP as 1.25V for 1GHZ on SW1 */
+		buf[2] = 0x30;
+		if (i2c_write(0x8, 24, 1, buf, 3)) {
+			printf("%s:i2c_write:error\n", __func__);
+			return -1;
+		}
+		if (i2c_read(0x8, 25, 1, &buf[0], 3)) {
+			printf("%s:i2c_read:error\n", __func__);
+			return -1;
+		}
+		/* increase VCC as 1.3V on SW2 */
+		buf[2] = 0x34;
+		if (i2c_write(0x8, 25, 1, buf, 3)) {
+			printf("%s:i2c_write:error\n", __func__);
+			return -1;
+		}
+		/*change global reset time as 4s*/
+		if (i2c_read(0x8, 15, 1, &buf[0], 3)) {
+			printf("%s:i2c_read:error\n", __func__);
+			return -1;
+		}
+		buf[1] |= 0x1;
+		buf[1] &= ~0x2;
+		if (i2c_write(0x8, 15, 1, buf, 3)) {
+			printf("%s:i2c_write:error\n", __func__);
+			return -1;
+		}
+
+		/* set up rev #1 for loco/ripley board */
+		setup_board_rev(get_board_rev_from_fuse());
+		/* Switch to 1GHZ */
+		clk_config(CONFIG_REF_CLK_FREQ, 1000, CPU_CLK);
+	} else if (!i2c_probe(0x48)) {
+		/* increase VDDGP as 1.25V for 1GHZ */
+		value = 0x5e;
+		do {
+			if (0 != i2c_write_check(0x48, 0x2e, 1, &value, 1)) {
+				printf("da9052_i2c_is_connected - i2c write failed.....\n");
+			} else {
+				printf("da9052_i2c_is_connected - i2c write success....\n");
+				ret = 0;
+			}
+		} while (ret != 0 && retries--);
+		i2c_read(0x48, 60, 1, &value, 1);
+		value |= 0x1;
+		i2c_write(0x48, 60, 1, &value, 1);
+		/* restore VUSB_2V5 when reset from suspend state */
+		value = BUCKPERI_RESTORE_SW_STEP;
+		i2c_write(0x48, DA9052_ID1213_REG, 1, &value, 1);
+		i2c_read(0x48, DA9052_SUPPLY_REG, 1, &value, 1);
+		value |= SUPPLY_RESTORE_VPERISW_EN;
+		i2c_write(0x48, DA9052_SUPPLY_REG, 1, &value, 1);
+
+		/* set up rev #0 for loco/da9053 board */
+		setup_board_rev(0);
+		/* Switch to 1GHZ */
+		clk_config(CONFIG_REF_CLK_FREQ, 1000, CPU_CLK);
+	} else
+		printf("Error: Dont't found mc34708 or da9052 on board.\n");
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("Board: ");
+	printf("MX53-LOCO 1.0 ");
+	switch (get_board_rev_from_fuse()) {
+	case 0x3:
+		printf("Rev. B\n");
+		break;
+	case 0x1:
+	default:
+		printf("Rev. A\n");
+		break;
+	}
+	printf("Boot Reason: [");
+	switch (__REG(SRC_BASE_ADDR + 0x8)) {
+	case 0x0001:
+		printf("POR");
+		break;
+	case 0x0009:
+		printf("RST");
+		break;
+	case 0x0010:
+	case 0x0011:
+		printf("WDOG");
+		break;
+	default:
+		printf("unknown");
+	}
+	printf("]\n");
+
+	printf("Boot Device: ");
+	switch (get_boot_device()) {
+	case WEIM_NOR_BOOT:
+		printf("NOR\n");
+		break;
+	case ONE_NAND_BOOT:
+		printf("ONE NAND\n");
+		break;
+	case PATA_BOOT:
+		printf("PATA\n");
+		break;
+	case SATA_BOOT:
+		printf("SATA\n");
+		break;
+	case I2C_BOOT:
+		printf("I2C\n");
+		break;
+	case SPI_NOR_BOOT:
+		printf("SPI NOR\n");
+		break;
+	case SD_BOOT:
+		printf("SD\n");
+		break;
+	case MMC_BOOT:
+		printf("MMC\n");
+		break;
+	case NAND_BOOT:
+		printf("NAND\n");
+		break;
+	case UNKNOWN_BOOT:
+	default:
+		printf("UNKNOWN\n");
+		break;
+	}
+	return 0;
+}
Двоичные файлы ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/mx53_regigraf.o и ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/mx53_regigraf.o различаются
diff -urN ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/u-boot.lds ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/u-boot.lds
--- ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf.orig/u-boot.lds	1970-01-01 03:00:00.000000000 +0300
+++ ./build/u-boot-2009.08.01-regigraf/board/freescale/mx53_regigraf/u-boot.lds	2013-08-13 13:11:17.297214112 +0400
@@ -0,0 +1,68 @@
+/*
+ * (C) Copyright 2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	   :
+	{
+	  /* WARNING - the following is hand-optimized to fit within	*/
+	  /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+	  board/freescale/mx53_regigraf/flash_header.o	(.text.flasheader)
+	  cpu/arm_cortexa8/start.o
+	  board/freescale/mx53_regigraf/libmx53_regigraf.a	(.text)
+	  lib_arm/libarm.a		(.text)
+	  net/libnet.a			(.text)
+	  drivers/mtd/libmtd.a		(.text)
+	  drivers/mmc/libmmc.a		(.text)
+
+	  . = DEFINED(env_offset) ? env_offset : .;
+	  common/env_embedded.o(.text)
+
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	_end_of_copy = .; /* end_of ROM copy code here */
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
--- ./build/u-boot-2009.08.01-regigraf/drivers/mmc/imx_esdhc.c.orig	2012-09-07 13:00:15.000000000 +0400
+++ ./build/u-boot-2009.08.01-regigraf/drivers/mmc/imx_esdhc.c	2013-05-30 11:04:09.000000000 +0400
@@ -488,10 +488,11 @@
 		tmp = readl(&regs->proctl) | PROCTL_DTW_8;
 		writel(tmp, &regs->proctl);
 	}
-
+#ifndef CONFIG_MXC_REGIGRAF_MMC
 	if (mmc->card_caps & EMMC_MODE_4BIT_DDR ||
 		mmc->card_caps & EMMC_MODE_8BIT_DDR)
 		esdhc_dll_setup(mmc);
+#endif
 }
 
 static int esdhc_init(struct mmc *mmc)
--- ./build/u-boot-2009.08.01-regigraf/drivers/mtd/nand/mxc_nand.c.orig	2012-09-07 13:00:15.000000000 +0400
+++ ./build/u-boot-2009.08.01-regigraf/drivers/mtd/nand/mxc_nand.c	2013-06-25 15:05:12.062502277 +0400
@@ -36,6 +36,43 @@
  */
 #define TROP_US_DELAY   2000
 
+#ifdef CONFIG_MXC_REGIGRAF_NAND
+/* Regigraf board */
+#define CLEAR_BITS(out, mask, offs) (out & ~(mask << offs))
+#define CHANGE_REG(getter, setter, mask, offs, value) \
+	setter(CLEAR_BITS(getter, mask, offs) | ((value) << offs))
+
+#define MXC_NFC_CFG_2          NFC_CONFIG2
+#define MXC_NFC_CFG_2_GET      __raw_readl(MXC_NFC_CFG_2)
+#define MXC_NFC_CFG_2_SET(val) __raw_writel(val, MXC_NFC_CFG_2)
+#define MXC_NFC_CFG_2_UP(mask, offs, val) \
+	CHANGE_REG(MXC_NFC_CFG_2_GET, MXC_NFC_CFG_2_SET, mask, offs, val)
+
+#define MXC_NFC_CFG_3          NFC_CONFIG3
+#define MXC_NFC_CFG_3_GET      __raw_readl(MXC_NFC_CFG_3)
+#define MXC_NFC_CFG_3_SET(val) __raw_writel(val, MXC_NFC_CFG_3)
+#define MXC_NFC_CFG_3_UP(mask, offs, val) \
+	CHANGE_REG(MXC_NFC_CFG_3_GET, MXC_NFC_CFG_3_SET, mask, offs, val)
+
+#define MXC_NFC_SPAS(val)           MXC_NFC_CFG_2_UP(0xFF, 16, val / 2)
+#define MXC_NFC_ADR_PHASES1(val)    MXC_NFC_CFG_2_UP(0x3,  12, val - 3)
+#define MXC_NFC_PPB(val)            MXC_NFC_CFG_2_UP(0x3,  7,  val)
+#define MXC_NFC_ECC_MODE(val)       MXC_NFC_CFG_2_UP(0x1,  6,  (val / 4) - 1)
+#define MXC_NFC_ADR_PHASES0(val)    MXC_NFC_CFG_2_UP(0x1,  5,  val - 1)
+#define MXC_NFC_CMD_PHASES(val)     MXC_NFC_CFG_2_UP(0x1,  4,  val - 1)
+#define MXC_NFC_ECC_EN(val)         MXC_NFC_CFG_2_UP(0x1,  3,  val)
+#define MXC_NFC_SYM(val)            MXC_NFC_CFG_2_UP(0x1,  2,  val)
+#define MXC_NFC_PS(val)             MXC_NFC_CFG_2_UP(0x3,  0,  val)
+
+#define MXC_NFC_RBB_MODE(val)       MXC_NFC_CFG_3_UP(0x1,  15, val)
+#define MXC_NFC_NUM_OF_DEVICES(val) MXC_NFC_CFG_3_UP(0x7,  12, val - 1)
+#define MXC_NFC_SBB(val)            MXC_NFC_CFG_3_UP(0x7,  8,  val)
+#define MXC_NFC_SB2R(val)           MXC_NFC_CFG_3_UP(0x7,  4,  val)
+#define MXC_NFC_FW(val)             MXC_NFC_CFG_3_UP(0x1,  3,  (16 / val) - 1)
+#define MXC_NFC_TOO(val)            MXC_NFC_CFG_3_UP(0x1,  2,  val - 1)
+#define MXC_NFC_ADD_OP(val)         MXC_NFC_CFG_3_UP(0x3,  0,  val)
+
+#endif
 /*
  * OOB placement block for use with hardware ecc generation
  */
@@ -57,6 +94,9 @@
 	.oobfree = {{2, 4} }
 };
 
+/* FIXIT: Regigraf board debug functions */
+static u8 select_dev_lun(struct mtd_info *mtd, u32 page_addr);
+/* ------------------------------------- */
 
 static void mxc_nand_bi_swap(struct mtd_info *mtd)
 {
@@ -548,6 +588,39 @@
 
 }
 
+/* FIXIT: Regigraf board debug functions */
+static void configure_auto_cmd(void)
+{
+	raw_write(raw_read(NFC_CONFIG1) & ~(0xF << 8), NFC_CONFIG1); // execute automatic operation 1 time
+	raw_write(raw_read(NFC_CONFIG1) & ~(7 << 4),   NFC_CONFIG1); // Ram Buffer Address 0
+	raw_write(raw_read(NFC_CONFIG1) & ~(1 << 1),   NFC_CONFIG1); // CE# signal operates normally
+	raw_write(raw_read(NFC_CONFIG1) & ~1,          NFC_CONFIG1); // Program/read main and spare area
+}
+
+static u8 select_dev_lun(struct mtd_info *mtd, u32 page_addr)
+{
+	u16 lun_id;
+	u8  ret;
+	if (page_addr < (1024 * 1024 * 1024)) // 8Gb => 1GB => 0 LUN
+		lun_id = 0;
+	else
+		lun_id = 1;
+	/* sending READ STATUS ENHANCED command to select LUN */
+	send_cmd_atomic(mtd, 0x78);
+	/* fill address */
+	send_addr(0x00); // page
+	send_addr(0x00); // block
+	send_addr(lun_id); // LUN
+	/* transfer data from nand */
+	configure_auto_cmd();
+	raw_write(NFC_OUTPUT, REG_NFC_OPS); // One page data out
+	wait_op_done(TROP_US_DELAY);
+	/* reading status */
+	ret = *((u8*)MAIN_AREA0);
+	return ret;
+}
+/* ------------------------------------- */
+
 static u16 mxc_do_status_auto(struct mtd_info *mtd)
 {
 	u16 status = 0;
@@ -634,7 +707,7 @@
 
 static void mxc_nand_enable_hwecc(struct mtd_info *mtd, int mode)
 {
-	raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN), REG_NFC_ECC_EN);
+//	raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN), REG_NFC_ECC_EN); // FIXIT
 	return;
 }
 
@@ -890,15 +963,18 @@
 	 */
 	switch (command) {
 	case NAND_CMD_STATUS:
+		select_dev_lun(mtd, page_addr); // FIXIT
 		info->col_addr = 0;
 		info->status_req = 1;
 		break;
 
 	case NAND_CMD_READ0:
+		select_dev_lun(mtd, page_addr); // FIXIT
 		info->col_addr = column;
 		break;
 
 	case NAND_CMD_READOOB:
+		select_dev_lun(mtd, page_addr); // FIXIT
 		info->col_addr = column;
 		command = NAND_CMD_READ0;
 		break;
@@ -939,6 +1015,8 @@
 		break;
 
 	case NAND_CMD_ERASE1:
+		select_dev_lun(mtd, page_addr); // FIXIT
+		break;
 	case NAND_CMD_ERASE2:
 		break;
 	}
@@ -1119,7 +1197,8 @@
 	.offs = 0,
 	.len = 4,
 	.veroffs = 4,
-	.maxblocks = 4,
+//	.maxblocks = 4, // FIXIT
+	.maxblocks = 8,
 	.pattern = bbt_pattern
 };
 
@@ -1129,7 +1208,8 @@
 	.offs = 0,
 	.len = 4,
 	.veroffs = 4,
-	.maxblocks = 4,
+//	.maxblocks = 4, // FIXIT
+	.maxblocks = 8,
 	.pattern = mirror_pattern
 };
 
@@ -1246,7 +1326,28 @@
 	raw_write(NFC_SET_WPC(NFC_WPC_UNLOCK), REG_NFC_WPC);
 #endif
 	/* Enable hw ecc */
-	raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN), REG_NFC_ECC_EN);
+//	raw_write((raw_read(REG_NFC_ECC_EN) | NFC_ECC_EN), REG_NFC_ECC_EN); // FIXIT
+#ifdef CONFIG_MXC_REGIGRAF_NAND
+	/* Regigraf board NFC configuration */
+	MXC_NFC_CFG_3_UP(0x1, 20, 1); // SDMA is not in being used for NFC operations
+	MXC_NFC_SPAS(218);     // 218 Spare size
+	MXC_NFC_PPB(1);        // 64 pages per block
+	MXC_NFC_ECC_MODE(8);   // set 8bit ECC
+	MXC_NFC_ECC_EN(0);     // disable ECC
+//	MXC_NFC_ECC_EN(1);     // enable ECC
+	MXC_NFC_SYM(0);        // set 2 clock per RE#WE# (asymmetric RE waveform)
+	MXC_NFC_PS(3);         // set 4KB page (11)
+	MXC_NFC_RBB_MODE(1);       // NFC monitors ready-busy status by checking ipp_nfc_rbbX signals
+	MXC_NFC_NUM_OF_DEVICES(1); // Num Of Devices: 1 dev
+	MXC_NFC_SBB(6);            // set READY bit 6 in status
+	MXC_NFC_SB2R(0);           // set FAIL bit 0 in status
+	MXC_NFC_FW(8);             // Nand Flash IO width: 8bit
+	MXC_NFC_TOO(1);            // Only 1 device is connected to all CS lines
+	MXC_NFC_ADD_OP(1);         // use only address group NAND_ADD[0-8] will only use one NAND
+	MXC_NFC_ADR_PHASES1(5);    // 5 phases during read/program oeprations
+	MXC_NFC_ADR_PHASES0(2);    // 2 phases less then NUM_ADR_PHASES1 (during an AUTO_ERASE operation)
+	MXC_NFC_CMD_PHASES(2);     // 2 command phases for reading a page (read command & read-confirm command)
+#endif
 }
 
 static int mxc_alloc_buf(struct nand_info *info)
@@ -1329,8 +1430,13 @@
 	this->ecc.hwctl = mxc_nand_enable_hwecc;
 	this->ecc.layout = &nand_hw_eccoob_512;
 	this->ecc.mode = NAND_ECC_HW;
+#ifdef CONFIG_MXC_REGIGRAF_NAND
+	this->ecc.bytes = 9;
+	this->ecc.size = 512;
+#else
 	this->ecc.bytes = 9;
 	this->ecc.size = 512;
+#endif
 
 #ifdef CONFIG_NAND_FW_16BIT
 	if (CONFIG_NAND_FW_16BIT == 1) {
--- ./build/u-boot-2009.08.01-regigraf/include/configs/mx51_regigraf.h.orig	2013-06-19 12:31:44.098854240 +0400
+++ ./build/u-boot-2009.08.01-regigraf/include/configs/mx51_regigraf.h	2013-06-17 16:45:24.269826771 +0400
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * (C) Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the MX51-3Stack Freescale board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/mx51.h>
+
+ /* High Level Configuration Options */
+#define CONFIG_ARMV7		1	/* This is armv7 Cortex-A8 CPU core */
+
+#define CONFIG_MXC		1
+#define CONFIG_MX51_BBG		1	/* in a mx51 */
+#define CONFIG_FLASH_HEADER	1
+#define CONFIG_FLASH_HEADER_OFFSET 0x400
+#define CONFIG_FLASH_HEADER_BARKER 0xB1
+
+#define CONFIG_SKIP_RELOCATE_UBOOT
+
+#define CONFIG_MX51_HCLK_FREQ	24000000	/* RedBoot says 26MHz */
+
+#define CONFIG_ARCH_CPU_INIT
+#define CONFIG_ARCH_MMU
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_SYS_64BIT_VSPRINTF
+
+#define BOARD_LATE_INIT
+/*
+ * Disabled for now due to build problems under Debian and a significant
+ * increase in the final file size: 144260 vs. 109536 Bytes.
+ */
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_REVISION_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(3 * 1024 * 1024)
+/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	128
+
+/*
+ * PLL clocks
+ */
+#define CONFIG_SYS_DDR_CLKSEL	0x0 /* Default setting: 0x0 */
+#define CONFIG_SYS_CLKTL_CBCDR 0x59E35100 /* Default setting: 0x59E35100 */
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_MXC_UART 1
+#define CONFIG_UART_BASE_ADDR   UART1_BASE_ADDR
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+
+#include <config_cmd_default.h>
+
+//#define CONFIG_CMD_PING
+//#define CONFIG_CMD_DHCP
+//#define CONFIG_BOOTP_SUBNETMASK
+//#define CONFIG_BOOTP_GATEWAY
+//#define CONFIG_BOOTP_DNS
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+//#define CONFIG_NET_RETRY_COUNT	100
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_MMC
+//#define CONFIG_CMD_IIM
+//#define CONFIG_CMD_I2C
+#define CONFIG_CMD_NAND
+
+//#define CONFIG_CMD_CLOCK
+//#define CONFIG_REF_CLK_FREQ CONFIG_MX51_HCLK_FREQ
+
+/*
+ * FUSE Configs
+ */
+#ifdef CONFIG_CMD_IIM
+	#define CONFIG_IMX_IIM
+	#define IMX_IIM_BASE        IIM_BASE_ADDR
+	#define CONFIG_IIM_MAC_BANK 1
+	#define CONFIG_IIM_MAC_ROW  9
+#endif
+
+/*
+ * SPI Configs
+ */
+#ifdef CONFIG_CMD_SF
+//	#define CONFIG_SPI_FLASH
+	#define CONFIG_FSL_SF              1
+	#define CONFIG_SPI_FLASH_IMX_ATMEL 1
+	#define CONFIG_SPI_FLASH_CS        1
+	#define CONFIG_IMX_ECSPI
+	#define IMX_CSPI_VER_2_3           1
+	#define CONFIG_IMX_SPI_PMIC
+	#define CONFIG_IMX_SPI_PMIC_CS     0
+	#define MAX_SPI_BYTES              (64 * 4)
+#endif
+
+/*
+ * MMC Configs
+ */
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC                1
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_SYS_FSL_ESDHC_NUM  1
+	#define CONFIG_SYS_FSL_ESDHC_ADDR 0
+	#define CONFIG_SYS_MMC_ENV_DEV    0
+	#define CONFIG_DOS_PARTITION      1
+	#define CONFIG_CMD_FAT            1
+	#define CONFIG_MXC_REGIGRAF_MMC
+//	#define CONFIG_DYNAMIC_MMC_DEVNO
+#endif
+
+/*
+ * I2C Configs
+ */
+#ifdef CONFIG_CMD_I2C
+	#define CONFIG_HARD_I2C         1
+	#define CONFIG_I2C_MXC          1
+	#define CONFIG_SYS_I2C_PORT             I2C1_BASE_ADDR
+	#define CONFIG_SYS_I2C_SPEED            400000
+	#define CONFIG_SYS_I2C_SLAVE            0xfe
+#endif
+
+/*
+ * Eth Configs
+ */
+#ifdef CONFIG_CMD_NET
+	#define CONFIG_HAS_ETH1
+	#define CONFIG_NET_MULTI 1
+	#define CONFIG_MXC_FEC
+	#define CONFIG_MII
+	#define CONFIG_DISCOVER_PHY
+
+	#define CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
+	#define CONFIG_IIM_MAC_ADDR_OFFSET      0x24
+
+	#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
+	#define CONFIG_FEC0_PINMUX	-1
+	#define CONFIG_FEC0_PHY_ADDR	0x1F
+	#define CONFIG_FEC0_MIIBASE 	-1
+	#define CONFIG_FEC_STATIC_MAC_ADDR {0x00, 0x00, 0x00, 0x00, 0x00, 0x01}
+#endif
+
+/*
+ * NAND Configs
+ */
+#ifdef CONFIG_CMD_NAND
+	#define CONFIG_MXC_NAND
+	#define CONFIG_MXC_NFC_SP_AUTO
+	#define CONFIG_MXC_REGIGRAF_NAND
+	#define CONFIG_SYS_NAND_LARGEPAGE
+	#define CONFIG_MTD_DEVICE
+	/* NAND FLASH driver setup */
+	#define NAND_MAX_CHIPS             1
+	#define CONFIG_SYS_NAND_MAX_CHIPS  1
+	#define CONFIG_SYS_MAX_NAND_DEVICE 1
+	#define CONFIG_SYS_NAND_BASE       0x40000000
+#endif
+
+/*
+ * Framebuffer and LCD
+ */
+#ifdef CONFIG_SPLASH_SCREEN
+	#define CONFIG_LCD
+	#define CONFIG_VIDEO_MX5
+	#define CONFIG_MXC_HSC
+	#define CONFIG_IPU_CLKRATE	133000000
+	#define CONFIG_SYS_CONSOLE_ENV_OVERWRITE
+	#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#define LCD_BPP		LCD_COLOR16
+	#define CONFIG_CMD_BMP
+	#define CONFIG_BMP_8BPP
+	#define CONFIG_FB_BASE	(TEXT_BASE + 0x300000)
+	#define CONFIG_SPLASH_SCREEN_ALIGN
+	#define CONFIG_SYS_WHITE_ON_BLACK
+#endif
+
+/* Enable below configure when supporting nand */
+#define CONFIG_CMD_ENV
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY	3
+
+#define CONFIG_PRIME	"FEC0"
+
+#define CONFIG_LOADADDR		0x90800000	/* loadaddr env var */
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+		"netdev=eth0\0"						\
+		"ethprime=FEC0\0"					\
+		"uboot_addr=0xa0000000\0"				\
+		"uboot=u-boot.bin\0"			\
+		"kernel=uImage\0"				\
+		"mmcdev=0\0" \
+		"mmcroot=/dev/mmcblk0p2 rw\0" \
+		"mmcrootfstype=ext2\0" \
+		"mtddev=ubi.mtd=1\0" \
+		"nandroot=ubi0:nandfs rw\0" \
+		"nandrootfstype=ubifs\0" \
+		"video=mxcdi1fb:RGB565,CLAA-WVGA di1_primary\0" \
+		"bootargs_base=setenv bootargs console=ttymxc0,115200\0"\
+		"bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs "\
+			"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0"\
+		"bootargs_mmc=setenv bootargs console=ttymxc0,115200 ${bootargs} root=${mmcroot} "\
+		  "rootfstype=${mmcrootfstype} rootwait video=${video} consoleblank=0\0" \
+		"bootargs_nand=setenv bootargs ${bootargs} ${mtddev} root=${nandroot} "\
+		  "rootfstype=${nandrootfstype} rootwait video=${video} consoleblank=0\0" \
+		"bootcmd_net=run bootargs_base bootargs_nfs; "		\
+			"tftpboot ${loadaddr} ${kernel}; bootm\0"	\
+		"bootcmd_mmc=mmc rescan; run bootargs_mmc; "		\
+			"fatload mmc ${mmcdev} ${loadaddr} ${kernel}; bootm\0"	\
+		"bootcmd_nand=mmc rescan; run bootargs_base bootargs_nand; "		\
+			"fatload mmc ${mmcdev} ${loadaddr} ${kernel}; bootm\0"	\
+		"load_uboot=tftpboot ${loadaddr} ${uboot}\0"		\
+		"bootcmd=run bootcmd_mmc\0"				\
+
+//		"bootcmd=run bootcmd_net\0"
+
+/*
+ * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
+ * U-Boot, RedBoot and Linux: the ethernet Rx signal is reaching the CS8900A
+ * controller inverted. The controller is capable of detecting and correcting
+ * this, but it needs 4 network packets for that. Which means, at startup, you
+ * will not receive answers to the first 4 packest, unless there have been some
+ * broadcasts on the network, or your board is on a hub. Reducing the ARP
+ * timeout from default 5 seconds to 200ms we speed up the initial TFTP
+ * transfer, should the user wish one, significantly.
+ */
+#define CONFIG_ARP_TIMEOUT	200UL
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT		"Regigraf U-Boot > "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
+
+#define CONFIG_SYS_MEMTEST_START	0x0	/* memtest works on */ /* old value: 0 */
+#define CONFIG_SYS_MEMTEST_END		0x10000
+
+//#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_HZ				1000
+
+#define CONFIG_CMDLINE_EDITING	1
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CSD0_BASE_ADDR
+#define PHYS_SDRAM_1_SIZE	(512 * 1024 * 1024)
+#define iomem_valid_addr(addr, size) \
+	(addr >= PHYS_SDRAM_1 && addr <= (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SECT_SIZE    (8 * 1024)
+#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
+
+/* Monitor at beginning of flash */
+/* #define CONFIG_FSL_ENV_IN_SF */
+#define CONFIG_FSL_ENV_IN_SF
+/* Example: CONFIG_ENV_IS_IN_{NVRAM|EEPROM|FLASH|DATAFLASH|ONENAND|SPI_FLASH|SATA|MMC|MG_DISK|NOWHERE} */
+#if defined(CONFIG_FSL_ENV_IN_NAND)
+	#define CONFIG_ENV_IS_IN_NAND  1
+	#define CONFIG_ENV_OFFSET      0x100000
+#elif defined(CONFIG_FSL_ENV_IN_MMC)
+	#define CONFIG_ENV_IS_IN_MMC 1
+	#define CONFIG_ENV_OFFSET    (768 * 1024)
+#elif defined(CONFIG_FSL_ENV_IN_SF)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH 1
+//	#define CONFIG_ENV_IS_EMBEDDED     1
+	#define CONFIG_ENV_SPI_MAX_HZ      25000000
+	#define CONFIG_ENV_SPI_CS          1
+	#define CONFIG_ENV_OFFSET          0x100000
+//	#define CONFIG_ENV_OFFSET          (768 * 1024)
+#else
+	#define CONFIG_ENV_IS_NOWHERE1
+#endif
+
+/*
+ * JFFS2 partitions
+ */
+#undef CONFIG_JFFS2_CMDLINE
+//#define CONFIG_JFFS2_DEV	"nand0"
+
+#endif				/* __CONFIG_H */
--- ./build/u-boot-2009.08.01-regigraf/include/configs/mx53_regigraf.h.orig	2013-08-09 17:00:34.296094271 +0400
+++ ./build/u-boot-2009.08.01-regigraf/include/configs/mx53_regigraf.h	2013-08-13 13:35:13.979152575 +0400
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the MX53-LOCO Freescale board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/mx53.h>
+
+ /* High Level Configuration Options */
+#define CONFIG_ARMV7		/* This is armv7 Cortex-A8 CPU core */
+#define CONFIG_MXC
+#define CONFIG_MX53
+#define CONFIG_MX53_LOCO
+#define CONFIG_FLASH_HEADER
+#define CONFIG_FLASH_HEADER_OFFSET 0x400
+#define CONFIG_MX53_CLK32	32768
+
+#define CONFIG_SKIP_RELOCATE_UBOOT
+
+#define CONFIG_ARCH_CPU_INIT
+#define CONFIG_ARCH_MMU
+
+#define CONFIG_MX53_HCLK_FREQ	24000000
+#define CONFIG_SYS_PLL2_FREQ    400
+#define CONFIG_SYS_AHB_PODF     2
+#define CONFIG_SYS_AXIA_PODF    0
+#define CONFIG_SYS_AXIB_PODF    1
+
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_SYS_64BIT_VSPRINTF
+
+#define BOARD_LATE_INIT
+/*
+ * Disabled for now due to build problems under Debian and a significant
+ * increase in the final file size: 144260 vs. 109536 Bytes.
+ */
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_REVISION_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(3 * 1024 * 1024)
+/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	128
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_MXC_UART 1
+#define CONFIG_UART_BASE_ADDR   UART1_BASE_ADDR
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_NET_RETRY_COUNT  100
+#define CONFIG_NET_MULTI 1
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_DNS
+
+/* Enable below configure when supporting nand */
+#define CONFIG_CMD_NAND
+#define CONFIG_MXC_NAND
+/* NAND FLASH driver setup */
+#define CONFIG_SYS_NAND_MAX_CHIPS     1
+#define CONFIG_SYS_MAX_NAND_DEVICE    1
+#define CONFIG_SYS_NAND_BASE          0x40000000
+#define CONFIG_NAND_FW_16BIT    0 /* 1: 16bit 0: 8bit */
+
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_ENV
+
+#define CONFIG_CMD_IIM
+
+#define CONFIG_CMD_CLOCK
+#define CONFIG_REF_CLK_FREQ CONFIG_MX53_HCLK_FREQ
+
+#define CONFIG_CMD_SATA
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY	3
+
+#define CONFIG_PRIME	"FEC0"
+
+#define CONFIG_LOADADDR		0x70800000	/* loadaddr env var */
+#define CONFIG_RD_LOADADDR	(CONFIG_LOADADDR + 0x300000)
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+		"ipaddr=192.168.0.136\0"      \
+		"netmask=255.255.255.0\0"     \
+		"ethaddr=00:1f:f2:00:00:00\0" \
+		"serverip=192.168.0.2\0"	\
+		"netdev=eth0\0"			\
+		"ethprime=FEC0\0"		\
+		"uboot=u-boot.bin\0"		\
+		"kernel=uImage\0"		\
+		"nfsroot=/home/user/nfsroot\0"	\
+		"bootargs_nfs=setenv bootargs console=ttymxc0,115200 root=/dev/nfs " \
+			"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"nfs_boot=run bootargs_nfs; tftpboot ${loadaddr} ${kernel}; bootm\0"	\
+		"mmc_boot=mmc rescan; fatload mmc 0 ${loadaddr} ${kernel}; bootm\0"	\
+		"sata_boot=sata init; fatload sata 0 ${loadaddr} ${kernel}; bootm\0"	\
+		"nand_boot=nand read ${loadaddr} 1A00000 5E0000; bootm\0"	\
+		"android_boot=mmc rescan; mmc read 0x70800000 0x800 0x2000; mmc read 0x70D00000 0x3000 0x300; bootm 0x70800000 0x70D00000\0" \
+		"safe_update=tftpboot ${loadaddr} uImage_safe; nand erase 1000000 a00000; nand write ${loadaddr} 1000000 a00000\0"	\
+		"system_update=tftpboot ${loadaddr} ${kernel}; nand erase 1a00000 5E0000; nand write ${loadaddr} 1A00000 5E0000\0"	\
+		"safe_boot=nand read ${loadaddr} 1000000 a00000; bootm\0"	\
+		"tftp_boot=tftpboot ${loadaddr} ${kernel}; bootm\0"		\
+		"env_erase=nand erase 200000 20000\0"		\
+		"bootcmd=run nand_boot\0"			\
+	\
+
+
+#define CONFIG_ARP_TIMEOUT	200UL
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT		"MX53-LOCO U-Boot > "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
+
+#define CONFIG_SYS_MEMTEST_START	0x7a000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x7f000000
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_HZ				1000
+
+#define CONFIG_CMDLINE_EDITING	1
+
+#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
+#define CONFIG_FEC0_PINMUX	-1
+#define CONFIG_FEC0_PHY_ADDR	-1
+#define CONFIG_FEC0_MIIBASE	-1
+
+//#define CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
+//#define CONFIG_IIM_MAC_ADDR_OFFSET      0x24
+
+#define CONFIG_MXC_FEC
+#define CONFIG_MII
+#define CONFIG_MII_GASKET
+#define CONFIG_DISCOVER_PHY
+
+/*
+ * FUSE Configs
+ * */
+#ifdef CONFIG_CMD_IIM
+	#define CONFIG_IMX_IIM
+	#define IMX_IIM_BASE    IIM_BASE_ADDR
+	#define CONFIG_IIM_MAC_BANK     1
+	#define CONFIG_IIM_MAC_ROW      9
+#endif
+
+/*
+ * I2C Configs
+ */
+#define CONFIG_CMD_I2C          1
+#define CONFIG_HARD_I2C         1
+#define CONFIG_I2C_MXC          1
+#define CONFIG_SYS_I2C_PORT             I2C1_BASE_ADDR
+#define CONFIG_SYS_I2C_SPEED            100000
+#define CONFIG_SYS_I2C_SLAVE            0xfe
+
+/*
+ * MMC Configs
+ */
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_SYS_FSL_ESDHC_NUM        1
+	#define CONFIG_SYS_FSL_ESDHC_ADDR       0
+	#define CONFIG_SYS_MMC_ENV_DEV  0
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+	#define CONFIG_CMD_EXT2		1
+
+	/* detect whether ESDHC1 or ESDHC3 is boot device */
+	#define CONFIG_DYNAMIC_MMC_DEVNO
+
+	#define CONFIG_EMMC_DDR_PORT_DETECT
+//	#define CONFIG_EMMC_DDR_MODE
+	/* port 1 (ESDHC3) is 8 bit */
+//	#define CONFIG_MMC_8BIT_PORTS	0x2
+#endif
+
+/*
+ * SATA Configs
+ */
+#ifdef CONFIG_CMD_SATA
+  #define CONFIG_DWC_AHSATA
+  #define CONFIG_SYS_SATA_MAX_DEVICE      1
+  #define CONFIG_DWC_AHSATA_PORT_ID       0
+  #define CONFIG_DWC_AHSATA_BASE_ADDR     SATA_BASE_ADDR
+  #define CONFIG_LBA48
+  #define CONFIG_LIBATA
+#endif
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CSD0_BASE_ADDR
+#define PHYS_SDRAM_1_SIZE	(512 * 1024 * 1024)
+#define PHYS_SDRAM_2		CSD1_BASE_ADDR
+#define PHYS_SDRAM_2_SIZE	(512 * 1024 * 1024)
+#define iomem_valid_addr(addr, size) \
+	(addr >= PHYS_SDRAM_1 && addr <= (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_NO_FLASH
+
+/* Monitor at beginning of flash */
+#define CONFIG_FSL_ENV_IN_NAND
+/* #define CONFIG_FSL_ENV_IN_SATA */
+
+#define CONFIG_ENV_SECT_SIZE    (8 * 1024)
+#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
+
+#if defined(CONFIG_FSL_ENV_IN_NAND)
+	#define CONFIG_ENV_IS_IN_NAND 1
+	#define CONFIG_ENV_OFFSET	0x200000
+#elif defined(CONFIG_FSL_ENV_IN_MMC)
+	#define CONFIG_ENV_IS_IN_MMC	1
+	#define CONFIG_ENV_OFFSET	(768 * 1024)
+#elif defined(CONFIG_FSL_ENV_IN_SATA)
+	#define CONFIG_ENV_IS_IN_SATA   1
+	#define CONFIG_SATA_ENV_DEV     0
+	#define CONFIG_ENV_OFFSET       (768 * 1024)
+#elif defined(CONFIG_FSL_ENV_IN_SF)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
+	#define CONFIG_ENV_SPI_CS		1
+	#define CONFIG_ENV_OFFSET       (768 * 1024)
+#else
+	#define CONFIG_ENV_IS_NOWHERE	1
+#endif
+#endif				/* __CONFIG_H */
